name: CI/CD - Build & Deploy Frontend to K8s (EC2)

on:
  push:
    branches:
      - master  # ou main, conforme o nome da sua branch principal

env:
  DOCKERHUB_USER: onegrao
  FRONT_PATH: client        # caminho do frontend no repositório
  NAMESPACE: app-demo       # namespace do cluster
  FRONT_DEPLOYMENT_NAME: frontend
  FRONT_CONTAINER_NAME: web
  BACK_DEPLOYMENT_NAME: backend
  BACK_CONTAINER_NAME: backend  # o nome do container no manifest do backend

jobs:
  build-and-push:
    name: Build and Push Frontend Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker Image
        working-directory: ${{ env.FRONT_PATH }}
        run: |
          IMAGE=${{ env.DOCKERHUB_USER }}/frontend
          echo "Docker Image: $IMAGE"
          echo "Building image: $IMAGE:1"

          docker build -t ${IMAGE}:1 -t ${IMAGE}:latest .
          docker push ${IMAGE}:1
          docker push ${IMAGE}:latest
        env:
          DOCKER_BUILDKIT: 1

  deploy:
    name: Deploy to K3s on EC2
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo (for manifests)
        uses: actions/checkout@v4

      - name: SSH into EC2 and Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script: |
            set -e
            IMAGE="${{ env.DOCKERHUB_USER }}/frontend:latest"
            echo "Deploying image: $IMAGE"

            # Atualiza o container no deployment existente
            sudo kubectl -n ${{ env.NAMESPACE }} set image deployment/${{ env.FRONT_DEPLOYMENT_NAME }} ${{ env.FRONT_CONTAINER_NAME }}=$IMAGE --record
            sudo kubectl -n ${{ env.NAMESPACE }} rollout status deployment/${{ env.FRONT_DEPLOYMENT_NAME }} --timeout=120s

            # Debug: verificar qual imagem está rodando nos pods
            sudo kubectl -n ${{ env.NAMESPACE }} get deployment ${{ env.FRONT_DEPLOYMENT_NAME }} -o yaml | grep image

            # Força o redeploy do backend mesmo que a imagem seja a mesma
            sudo kubectl -n ${{ env.NAMESPACE }} rollout restart deployment/${{ env.BACK_DEPLOYMENT_NAME }}

            # Aguarda os pods ficarem prontos
            sudo kubectl -n ${{ env.NAMESPACE }} rollout status deployment/${{ env.BACK_DEPLOYMENT_NAME }} --timeout=120s

            # Debug: verificar qual imagem está rodando nos pods
            sudo kubectl -n ${{ env.NAMESPACE }} get deployment ${{ env.BACK_DEPLOYMENT_NAME }} -o yaml | grep image

              echo "✅ Deploy do backend finalizado com sucesso!"


            echo "✅ Deploy do frontend finalizado com sucesso!"
